###################
# VJ Usage Step 3 #
###################

# Code modified from: github.com/pughlab/capTCR_seqAnalysis/blob/main/R/VJCassetteUsage/Step3_aaCDR3perVJ_PackedCirclePlot.R

# Required Libraries:
library (tidyverse)
library (ggraph)
library (igraph)
library (gridExtra)
library(bioseq)

# Creates VJ usage circle plot from data used in step 1 and 2
# @param patient: Patient desired for analysis
# @param cohort: Sample cohort desired for analysis
# @param timepoint_order: Ordering of the samples desired for analysis
# @param fig_height: Desired height of the figure (for manuscript figure_height equals 1)
# @param fig_width: Desired width of the figure (for manuscript figure_width equals 1x # of samples)
# @param fig_path: Desired output path of figure png

VJUsage_Step3 <- function(patient, cohort, timepoint_order, fig_height, fig_width, fig_path){
    
    #If you have multiple patients and want to arrange the 
    #plots in multiple columns when plotting them side by side, 
    #define the number of columns:
    #example: if you have 30 timepoints, you might want to plot them
    #in a 5-row*6-column grid. so, the  number_of_columns <- 6.
    number_of_columns <- length(timepoint_order)

    #Name of your final figure. This name should end
    #with '.png'. Example: 'ProjectX_Blood.png'
    fig_name  <- paste("TLML_VJUsage", cohort, patient, ".png", sep="_")

    #height and width of your figure. You can select these variables
    #based on the number of rows and columns in your figure.
    #Suggestion: for a 5-row*6-column figure you can proceed with 
    # '5*2=10' height and '6*3=18' width 

    #Reading the input files:      
    #Concatenated file generated by '''Step2_TRBclonotype_txtFile_concatenation.R'''
    clonotypes <- clonotypes %>% 
            filter ( Patient_id %in% patient)%>%
            filter ( Cohort == cohort) %>%
            mutate(VJcombo = gsub("[.]", "_", VJcombo))
            #mutate ( VJcombo = stringr::str_c(Vcassette ,      #Because the presence of dot'.' symbol is a source of error for ggraph
                                             #"_" ,             #we need to re-generate VJcombo column, where V and J genes are glued
                                             #Jcassette) )      #by "_" instead of ".".

    clonotypes <- clonotypes[-c(grep("[*]", clonotypes$aaSeqCDR3)),]
    clonotypes <- clonotypes[-c(grep("_", clonotypes$aaSeqCDR3)),]
    for(clone in 1:length(clonotypes$cloneFraction)){
        clonotypes$cloneFraction[clone] <- clonotypes$cloneCount[clone]/sum(clonotypes[which(clonotypes$Cycle==clonotypes$Cycle[clone]),]$cloneCount)
    }

    #Concatenated file generated by '''Step1_aaCDR3perVJ_input_generation.R'''
    cassette_stats <-  cassette_stats %>%
            filter ( Patient_id %in% patient ) %>%
            filter ( Number_aaCDR3 > 1 ) %>%
            filter ( Cohort == cohort ) %>%
            select ( Patient_id , Cycle , VJcombo ) %>%
            mutate ( VJcombo = str_replace ( VJcombo , "\\.", "_"))
    
    aaSeqCDR3_colors <- CDR3_colors[which(CDR3_colors$id==patient),]
    ########################################################################
    ###MAKING A LIST TO STORE THE GRAPHS:
    #'''''''Begins here
    timepoint_list <- unique(clonotypes$Cycle)
    timepoint_list <- timepoint_list[order(match(timepoint_list, timepoint_order))]
    graph_data <- list()
    a <- 1

    for (i in c(1:length(timepoint_list))) {

            trial <- clonotypes %>% 
                    filter ( Patient_id == patient )%>%
                    filter ( Cycle == timepoint_list[i] ) %>%
                    filter ( Cohort == cohort)

            trial$cycle <- paste("T" , 
                              seq.int(nrow(trial)) , 
                              sep = "") 
            #######################################
            ###Constructing the edges
            #layer1:
            layer1 <- unique(trial %>% 
                                     select(Cycle , VJcombo )
                             )

            layer1$to <- stringr::str_c(layer1$Cycle , 
                                        "." , 
                                        layer1$VJcombo)

            names(layer1) <- c("from" ,
                               "VJcombo" ,   
                               "to"     )

            #layer2:

            layer2 <- trial %>% 
                    select( Cycle , VJcombo , nSeqCDR3 )

            layer2$from <- stringr::str_c (layer2$Cycle , 
                                          "." , 
                                          layer2$VJcombo)

            layer2$to   <- stringr::str_c (layer2$Cycle , 
                                           "." , 
                                           layer2$VJcombo , 
                                           "." , 
                                           layer2$nSeqCDR3)

            #layer3:

            layer3 <- trial %>% 
                    select( Cycle , VJcombo , nSeqCDR3 , Patient_id , cloneCount) 

            layer3$from <- stringr::str_c(layer3$Cycle , 
                                          "." , 
                                          layer3$VJcombo , 
                                          "." , 
                                          layer3$nSeqCDR3)

            layer3$to   <- stringr::str_c(layer3$Cycle , 
                                          "." , 
                                          layer3$VJcombo , 
                                          "." , 
                                          layer3$nSeqCDR3 , 
                                          "." , 
                                          layer3$Patient_id)

            #Merging the layers:
            vjcass_edges <- rbind(layer1 %>% select(from , to),
                                  layer2 %>% select(from , to),
                                  layer3 %>% select(from , to)
                                  )

            #######################################
            ###Constructing the vertices
            super_classes <- as.data.frame(
                    rbind(
                            cbind(unique(layer1$from) , 0) ,  
                            cbind(unique(layer2$from) , 0) ,
                            cbind(unique(layer3$from) , 0)
                            )
                    )  
            names(super_classes) <- c("name" , "size")

            last_class <- layer3 %>% 
                    select(to , cloneCount)

            names(last_class) <- c("name" , "size")
            super_classes$size <- as.character(super_classes$size)
            vjcass_vertices <- rbind(super_classes   , as.data.frame(last_class))
            vjcass_vertices <- cbind(vjcass_vertices , timepoint_list[i])

            #######################################
            ###Converting data to graphs and storing them in a list:
            graph_data[[a]] <- graph_from_data_frame ( vjcass_edges , 
                                                      vertices = vjcass_vertices)
            V(graph_data[[a]])$color_status <- NA
            a <- a + 1


            rm (trial ,
                layer1 ,
                layer2 , 
                layer3 ,
                vjcass_edges ,
                super_classes , 
                last_class ,
                vjcass_vertices )

    }
    
    #'''''''Ends here
    ########################################################################
    ###Adding features that define whether a circle should be filled or remain 
    ###vacant based on the number of CDR3s each cassette encodes:
    #'''''''Begins here
    for (i in c(1:length(graph_data))) {
            p_id <- V(graph_data[[i]])$name[1]
            vj_dir <- cassette_stats$VJcombo [ cassette_stats$Cycle == p_id ]
            for (j in c(1:length(V(graph_data[[i]])$name))) {
                    if (length (str_split(V(graph_data[[i]])$name[j] , pattern = "\\.")[[1]]) < 4){ 
                            V(graph_data[[i]])$color_status [j] <- 1
                            cyc <- str_split(V(graph_data[[i]])$name[j], pattern="\\.")[[1]][1]
                            vj <- str_split(V(graph_data[[i]])$name[j], pattern="\\.")[[1]][2]
                            p_clonotypes <- clonotypes[which(clonotypes$Cycle==cyc),]
                            p_clonotypes <- p_clonotypes[which(p_clonotypes$VJcombo==vj),]
                            if((length(p_clonotypes$aaSeqCDR3)==1)&(length(which(p_clonotypes$aaSeqCDR3 %in% aaSeqCDR3_colors$colored_clns==TRUE))==1)){
                                V(graph_data[[i]])$color_status[j] <- which(aaSeqCDR3_colors$colored_clns==p_clonotypes$aaSeqCDR3) + 2
                            }
                    }
                    else {
                            if (str_split(V(graph_data[[i]])$name[j] , pattern = "\\.")[[1]][2] %in% vj_dir){
                                aaSeq <- toString(seq_translate(dna(str_split(V(graph_data[[i]])$name[j] , pattern = "\\.")[[1]][3])))
                                if(aaSeq %in% aaSeqCDR3_colors$colored_clns){
                                    V(graph_data[[i]])$color_status [j] <- which(aaSeqCDR3_colors$colored_clns==aaSeq) + 2
                                    }
                                else{
                                   V(graph_data[[i]])$color_status [j] <- 2 
                                }
                            }
                            else {
                                    V(graph_data[[i]])$color_status[j] <- 1

                            }

                    }
            }
        }

    #'''''''Ends here
    ########################################################################
    ###Making plots and storing the plots in a list:
    #'''''''Begins here
    ggraph_plots <- list()


    for (i in c(1:length(graph_data))) {

            ggraph_plots [[i]] <- ggraph(graph_data[[i]] , 
                                         layout = 'circlepack',  
                                         weight = as.numeric(
                                                 V(graph_data[[i]])$size
                                                 ) 
                                         ) + 
                    geom_node_circle( size = 0.05 , 
                                      aes_(
                                              fill = as.factor (
                                              V(graph_data[[i]])$color_status
                                              )
                                              )
                                      )+
                    scale_fill_manual(values = c("transparent" , "grey",
                                                 aaSeqCDR3_colors$mycolors),
                                      breaks = c(1:length(aaSeqCDR3_colors$mycolors))
                                      )+
              theme_graph()+
                    theme(legend.position = "None" ,
                          plot.margin = unit(c(0.001 ,
                                               0.001 ,
                                               0.001 ,
                                               0.001 ), "cm"),
                          plot.title = element_text ( hjust = 0 , 
                                                      vjust = -5 ,  
                                                      family = "Helvetica", 
                                                      size = 10 , 
                                                      face = "plain" )
                    )+
                    coord_fixed()


    }
    #'''''''Ends here
    ########################################################################
    #Printing the plots and saving the results:
    ggraph_plots <<- ggraph_plots
     png(
            file.path(
                    fig_path , fig_name
                    )  ,
            height =  fig_height ,
            width  =  fig_width,
            res    = 5000 , 
            units  = "in" ,
            bg     = "transparent"
            )

    if(patient=="TLML_1_" & cohort=="DNA"){
      layout_matrix <- c(1,2,NA,3,4,5)
    }
    else{
      layout_matrix <- c(1:length(timepoint_list))
    }
    gridExtra::grid.arrange(grobs = ggraph_plots, layout_matrix=rbind(layout_matrix),
                             ncol = length(layout_matrix))
    dev.off()
}

