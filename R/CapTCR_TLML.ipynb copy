{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "# Data Load and Organization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "hidden": true
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Loading required package: dplyr\n",
      "\n",
      "Attaching package: ‘dplyr’\n",
      "\n",
      "The following objects are masked from ‘package:stats’:\n",
      "\n",
      "    filter, lag\n",
      "\n",
      "The following objects are masked from ‘package:base’:\n",
      "\n",
      "    intersect, setdiff, setequal, union\n",
      "\n",
      "Loading required package: dtplyr\n",
      "Loading required package: data.table\n",
      "\n",
      "Attaching package: ‘data.table’\n",
      "\n",
      "The following objects are masked from ‘package:dplyr’:\n",
      "\n",
      "    between, first, last\n",
      "\n",
      "Loading required package: gridExtra\n",
      "\n",
      "Attaching package: ‘gridExtra’\n",
      "\n",
      "The following object is masked from ‘package:dplyr’:\n",
      "\n",
      "    combine\n",
      "\n",
      "Loading required package: ggpubr\n",
      "Loading required package: magrittr\n",
      "\n",
      "********************************************************\n",
      "Note: As of version 1.0.0, cowplot does not change the\n",
      "  default ggplot2 theme anymore. To recover the previous\n",
      "  behavior, execute:\n",
      "  theme_set(theme_cowplot())\n",
      "********************************************************\n",
      "\n",
      "\n",
      "Attaching package: ‘cowplot’\n",
      "\n",
      "The following object is masked from ‘package:ggpubr’:\n",
      "\n",
      "    get_legend\n",
      "\n"
     ]
    }
   ],
   "source": [
    "###################################\n",
    "# Longitudinally Ordering Samples # \n",
    "###################################\n",
    "\n",
    "# Creating a set of lists of the order of the samples in each cohort. \n",
    "TLML_1_gDNA <- c(\"apheresis_2013_9\", 'infusion_2013_8', \"FU_01_2014_1\", \"FU_02_2014_4\", \"FU_03_2014_7\")\n",
    "TLML_1_cDNA <- c('4W_2013_11', 'FU_07_2015_2', 'FU_10_2015_6', 'FU_12_2015_10', 'FU_13_2015_11', 'FU_16_2016_6')\n",
    "TLML_4_gDNA <- c('baseline_2015_10', 'infusion_2013_11', '4W_2014_12', 'FU_01_2015_1')\n",
    "TLML_4_cDNA <- c('baseline_2015_10', 'infusion_2013_11', '4W_2014_12', 'FU_01_2015_1')\n",
    "TLML_4_cfDNA <- c('baseline_2015_10', '4W_2014_12')\n",
    "TLML_7_gDNA <- c('apheresis_2014_3', 'infusion_2014_2', '4W_2014_4', '12W_2014_6', '17W_2014_7')\n",
    "TLML_7_cDNA <- c('apheresis_2014_3', 'infusion_2014_2', '4W_2014_4', '12W_2014_6')\n",
    "TLML_16gDNA <- c('baseline_2015_1', 'infusion_2014_4', '4W_2015_2', 'FU_01_2015_3', 'FU_02_2015_5', 'FU_03_2015_6', 'FU_04_2015_7', 'FU_05_2015_9')\n",
    "TLML_16cDNA <- c('baseline_2015_1', 'infusion_2014_4', 'FU_01_2015_3', 'FU_02_2015_5', 'FU_03_2015_6', 'FU_04_2015_7', 'FU_05_2015_9')\n",
    "TLML_16cfDNA <- c('baseline_2015_1', '4W_2015_2')\n",
    "TLML_18gDNA <- c('apheresis_2014_8', 'infusion_2014_6', '4W_2014_9')\n",
    "TLML_18cDNA <- c('apheresis_2014_8', 'infusion_2014_6', '4W_2014_9')\n",
    "TLML_20gDNA <- c('baseline_2_2015_1', 'infusion_2014_7', '4W_2015_2', 'FU_01_2015_3', 'FU_02_2015_6')\n",
    "TLML_20cDNA <- c('baseline_2_2015_1', 'infusion_2014_7', '4W_2015_2', 'FU_01_2015_3', 'FU_02_2015_6')\n",
    "TLML_20cfDNA <- c('baseline_2_2015_1', '4W_2015_2')\n",
    "TLML_22gDNA <- c('baseline_2014_12', 'infusion_2014_9', '4W_2015_1', 'FU_01_2015_2', 'FU_02_2015_3', 'FU_03_2015_4')\n",
    "TLML_22cDNA <- c('infusion_2014_9', '4W_2015_1', 'FU_01_2015_2', 'FU_02_2015_3', 'FU_03_2015_4')\n",
    "TLML_22cfDNA <- c('baseline_2014_12', '4W_2015_1')\n",
    "TLML_26gDNA <- c('apheresis_2014_11', 'infusion_2014_6','4W_2015_3', 'FU_01_2015_7', 'FU_02_2015_9')\n",
    "TLML_26cDNA <- c('baseline_2015_1', '4W_2015_3')\n",
    "TLML_26cfDNA <- c('baseline_2015_1', '4W_2015_3')\n",
    "TLML_29gDNA <- c('baseline_2016_1', 'infusion_2015_10', '4W_2016_2')\n",
    "TLML_29cDNA <- c('baseline_2016_1', 'infusion_2015_10', '4W_2016_2')\n",
    "TLML_29cfDNA <- c('baseline_2016_1', '4W_2016_2')\n",
    "TLDC_1_gDNA <- c('baseline_2015_11', 'infusion_NA_NA', '4W_2015_12')\n",
    "TLDC_1_cDNA <- c('baseline_2015_11', 'infusion_NA_NA', '4W_2015_12')\n",
    "TLDC_1_cfDNA <- c('baseline_2015_11', '4W_2015_12')\n",
    "\n",
    "#####################\n",
    "# Loading Libraries #\n",
    "#####################\n",
    "\n",
    "# Loading required libraries & options (if not previously installed, you must first install these packages)\n",
    "library(ggplot2)\n",
    "library(ggalluvial)\n",
    "library(immunarch)\n",
    "library(readxl)\n",
    "library(cowplot)\n",
    "options(scipen = 999)\n",
    "\n",
    "#########################################\n",
    "# Loading Manual Distinct Color Pallete #\n",
    "#########################################\n",
    "\n",
    "# Maximally distant color pallete excluding black and white\n",
    "\n",
    "colors <- c(\"#FFFF00\",\"#1CE6FF\",\"#FF34FF\",\"#FF4A46\",\"#008941\",\"#006FA6\",\"#A30059\",\"#FFDBE5\",\"#7A4900\",\"#0000A6\",\n",
    "           \"#63FFAC\",\"#B79762\",\"#004D43\",\"#8FB0FF\",\"#997D87\",\"#5A0007\",\"#809693\",\"#FEFFE6\",\"#1B4400\",\"#4FC601\",\"#3B5DFF\",\n",
    "           \"#4A3B53\",\"#FF2F80\",\"#61615A\",\"#BA0900\",\"#6B7900\",\"#00C2A0\",\"#FFAA92\",\"#FF90C9\",\"#B903AA\",\"#D16100\",\"#DDEFFF\",\n",
    "           \"#000035\",\"#7B4F4B\",\"#A1C299\",\"#300018\",\"#0AA6D8\",\"#013349\",\"#00846F\",\"#372101\",\"#FFB500\",\"#C2FFED\",\"#A079BF\",\n",
    "           \"#CC0744\",\"#C0B9B2\",\"#C2FF99\",\"#001E09\",\"#00489C\",\"#6F0062\",\"#0CBD66\",\"#EEC3FF\",\"#456D75\",\"#B77B68\",\"#7A87A1\",\n",
    "           \"#788D66\",\"#885578\",\"#FAD09F\",\"#FF8A9A\",\"#D157A0\",\"#BEC459\",\"#456648\",\"#0086ED\",\"#886F4C\",\"#34362D\",\"#B4A8BD\",\n",
    "           \"#00A6AA\",\"#452C2C\",\"#636375\",\"#A3C8C9\",\"#FF913F\",\"#938A81\",\"#575329\",\"#00FECF\",\"#B05B6F\",\"#8CD0FF\",\"#3B9700\",\n",
    "           \"#04F757\",\"#C8A1A1\",\"#1E6E00\",\"#7900D7\",\"#A77500\",\"#6367A9\",\"#A05837\",\"#6B002C\",\"#772600\",\"#D790FF\",\"#9B9700\",\n",
    "           \"#549E79\",\"#FFF69F\",\"#201625\",\"#72418F\",\"#BC23FF\",\"#99ADC0\",\"#3A2465\",\"#922329\",\"#5B4534\",\"#FDE8DC\",\"#404E55\",\n",
    "           \"#0089A3\",\"#CB7E98\",\"#A4E804\",\"#324E72\",\"#6A3A4C\",\"#83AB58\",\"#001C1E\",\"#D1F7CE\",\"#004B28\",\"#C8D0F6\",\"#A3A489\",\n",
    "           \"#806C66\",\"#222800\",\"#BF5650\",\"#E83000\",\"#66796D\",\"#DA007C\",\"#FF1A59\",\"#8ADBB4\",\"#1E0200\",\"#5B4E51\",\"#C895C5\",\n",
    "           \"#320033\",\"#FF6832\",\"#66E1D3\",\"#CFCDAC\",\"#D0AC94\",\"#7ED379\",\"#012C58\",\"#7A7BFF\",\"#D68E01\",\"#353339\",\"#78AFA1\",\n",
    "           \"#FEB2C6\",\"#75797C\",\"#837393\",\"#943A4D\",\"#B5F4FF\",\"#D2DCD5\",\"#9556BD\",\"#6A714A\",\"#001325\",\"#02525F\",\"#0AA3F7\",\n",
    "           \"#E98176\",\"#DBD5DD\",\"#5EBCD1\",\"#3D4F44\",\"#7E6405\",\"#02684E\",\"#962B75\",\"#8D8546\",\"#9695C5\",\"#E773CE\",\"#D86A78\",\n",
    "           \"#3E89BE\",\"#CA834E\",\"#518A87\",\"#5B113C\",\"#55813B\",\"#E704C4\",\"#00005F\",\"#A97399\",\"#4B8160\",\"#59738A\",\"#FF5DA7\",\n",
    "           \"#F7C9BF\",\"#643127\",\"#513A01\",\"#6B94AA\",\"#51A058\",\"#A45B02\",\"#1D1702\",\"#E20027\",\"#E7AB63\",\"#4C6001\",\"#9C6966\",\n",
    "           \"#64547B\",\"#97979E\",\"#006A66\",\"#391406\",\"#F4D749\",\"#0045D2\",\"#006C31\",\"#DDB6D0\",\"#7C6571\",\"#9FB2A4\",\"#00D891\",\n",
    "           \"#15A08A\",\"#BC65E9\",\"#C6DC99\",\"#203B3C\",\"#671190\",\"#6B3A64\",\"#F5E1FF\",\"#FFA0F2\",\"#CCAA35\",\"#374527\",\n",
    "           \"#8BB400\",\"#797868\",\"#C6005A\",\"#3B000A\",\"#C86240\",\"#29607C\",\"#402334\",\"#7D5A44\",\"#CCB87C\",\"#B88183\",\"#AA5199\",\n",
    "           \"#B5D6C3\",\"#A38469\",\"#9F94F0\",\"#A74571\",\"#B894A6\",\"#71BB8C\",\"#00B433\",\"#789EC9\",\"#6D80BA\",\"#953F00\",\"#5EFF03\",\n",
    "           \"#E4FFFC\",\"#1BE177\",\"#BCB1E5\",\"#76912F\",\"#003109\",\"#0060CD\",\"#D20096\",\"#895563\",\"#29201D\",\"#5B3213\",\"#A76F42\",\n",
    "           \"#89412E\",\"#1A3A2A\",\"#494B5A\",\"#A88C85\",\"#F4ABAA\",\"#A3F3AB\",\"#00C6C8\",\"#EA8B66\",\"#958A9F\",\"#BDC9D2\",\"#9FA064\",\n",
    "           \"#BE4700\",\"#658188\",\"#83A485\",\"#453C23\",\"#47675D\",\"#3A3F00\",\"#061203\",\"#DFFB71\",\"#868E7E\",\"#98D058\",\"#6C8F7D\",\n",
    "           \"#D7BFC2\",\"#3C3E6E\",\"#D83D66\",\"#2F5D9B\",\"#6C5E46\",\"#D25B88\",\"#5B656C\",\"#00B57F\",\"#545C46\",\"#866097\",\"#365D25\",\n",
    "           \"#252F99\",\"#00CCFF\",\"#674E60\",\"#FC009C\",\"#92896B\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "###########################################################################\n",
    "# Creates new cloneFraction column based on a subset of the original data #\n",
    "###########################################################################\n",
    "\n",
    "# Readjusts clone fraction data based on spliced data frame\n",
    "# @param input: Clone data loaded from the 'Load_data' function\n",
    "\n",
    "ProdcloneFrac <- function(input){ \n",
    "    \n",
    "    # Creating list of files used in input data\n",
    "    filenames <- unique(input$filename)\n",
    "    \n",
    "    # Adjusting clone fraction data of a splied dataframe\n",
    "    output_df <- data.frame()\n",
    "    for(i in 1:length(filenames)){\n",
    "        subset_fraction <- dplyr::filter(input, grepl(filenames[i], filename)) \n",
    "        totalClone <- sum(subset_fraction$cloneCount)\n",
    "        subset_fraction$cloneFraction <- as.numeric(as.character(subset_fraction$cloneCount))/totalClone\n",
    "        output_df <-rbind(output_df, subset_fraction)\n",
    "    }\n",
    "    \n",
    "    # Creating global variable for further analysis\n",
    "    output_df <<- output_df\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "################\n",
    "# Loading Data #\n",
    "################\n",
    "\n",
    "# Loading specific chain, sample cohort, and clonefrac for a specific patient's samples\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "\n",
    "Load_data <- function(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys){\n",
    "\n",
    "    # Loading data from the sample keys in order to convert file names into readable format\n",
    "    samplekeys <- read_excel(paste(dir_samplekeys, file_samplekeys, sep=\"\"))\n",
    "    for(i in 1:nrow(samplekeys)){\n",
    "        samplekeys$Informatics_Name[i] <- sub(\"*genomic*\", \"DNA\", samplekeys$Informatics_Name[i]) \n",
    "    }\n",
    "    samplekeys <<- samplekeys\n",
    "    \n",
    "    # Creating list of clone files for specific patient, sample cohort, and TCR chain\n",
    "    files <- list.files(paste(dir_clones, sampcohort, \"/CLONES_\", chain, patient, \"/\", sep = \"\"))\n",
    "    \n",
    "    # Longitudinally orders the samples from previously assigned variables\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "\n",
    "    #Compile a big file with patient's clone files\n",
    "    i <- 1\n",
    "    for (f in files){\n",
    "        mixcrfle <- read.table(paste(dir_clones, sampcohort, \"/CLONES_\", chain, patient, \"/\", f, sep = \"\"), \n",
    "                                       header = TRUE, sep = \"\\t\",\n",
    "                                       stringsAsFactors = FALSE,\n",
    "                                       na.strings = c(\"\", \"NA\"))\n",
    "        if(i == 1){\n",
    "            compldfle <- mixcrfle[!duplicated(mixcrfle$aaSeqCDR3),]\n",
    "            compldfle <- cbind(cloneno = row.names(compldfle), \n",
    "                             filename = f, \n",
    "                             compldfle)\n",
    "            i <- i + 1  \n",
    "            }\n",
    "        else{\n",
    "            compldfle1 <- mixcrfle[!duplicated(mixcrfle$aaSeqCDR3),]\n",
    "            compldfle1 <- cbind(cloneno = row.names(compldfle1), \n",
    "                              filename = f, \n",
    "                              compldfle1)\n",
    "            compldfle <- rbind(compldfle, compldfle1)\n",
    "            rm(compldfle1)\n",
    "            }\n",
    "        }\n",
    "\n",
    "    # Subseting dataframe to necessary clonal and CDR3 data\n",
    "    preCDR3_fraction <- compldfle[, c(\"filename\",\"aaSeqCDR3\",\"cloneFraction\", \"cloneCount\")] \n",
    "    \n",
    "    # Removes empty clones and clones with only 1 occurence\n",
    "    preCDR3_fraction <- preCDR3_fraction[which(preCDR3_fraction$cloneCount>1),]\n",
    "    unproductive <<- preCDR3_fraction\n",
    "    \n",
    "    # Removes unproductive clonotypes (NOTE: An extra clone \"CDR3*\" is added to solve null set problem)\n",
    "    preCDR3_fraction <- preCDR3_fraction[-c(grep(\"[*]\", c(preCDR3_fraction$aaSeqCDR3, \"CDR3*\"))),]\n",
    "    preCDR3_fraction <- preCDR3_fraction[-c(grep(\"_\", c(preCDR3_fraction$aaSeqCDR3, \"CDR3_\"))),]\n",
    "    \n",
    "    # Readjusting clonal fraction values to spliced data\n",
    "    ProdcloneFrac(preCDR3_fraction)\n",
    "    CDR3_fraction <- output_df\n",
    "    \n",
    "    # Removing clonotypes above defined clone fraction\n",
    "    CDR3_fraction <- CDR3_fraction[(CDR3_fraction$cloneFraction > clnefrc),]\n",
    "    # Number of samples\n",
    "    mysamples <- unique(CDR3_fraction$filename)\n",
    "\n",
    "    # Changing the sample names to readable format through referencing sample keys dataframe 'samplekeys'\n",
    "    CDR3_fraction$filename <- as.character(CDR3_fraction$filename)\n",
    "    for(i in 1:nrow(CDR3_fraction)){\n",
    "        CDR3_fraction$filename[i] <- sub(\"*genomic*\", \"DNA\", CDR3_fraction$filename[i])\n",
    "    }\n",
    "    h <- 1\n",
    "    for (f in CDR3_fraction$filename){\n",
    "        j <- 1\n",
    "        for(i in samplekeys$Informatics_Name){\n",
    "            if(grepl(i, f) == TRUE){\n",
    "                file = paste(samplekeys$Timepoint[j],\n",
    "                            samplekeys$Sample_Year[j],\n",
    "                            samplekeys$Sample_Month[j], sep=\"_\")\n",
    "                CDR3_fraction$filename[h] = file\n",
    "            }\n",
    "            j <- j+1\n",
    "        }\n",
    "        h <- h + 1\n",
    "    }\n",
    "    if(patient==\"TLML_26\"){\n",
    "        CDR3_fraction <- CDR3_fraction[-c(which(CDR3_fraction$filename=='BL_2015_1')),]\n",
    "    }\n",
    "    \n",
    "    CDR3_fraction <<- CDR3_fraction\n",
    "\n",
    "    # Creating custom dataframes for the TIL Infusion product, 4W sample, and baseline sample\n",
    "    TIL_data <<- dplyr::filter(CDR3_fraction, grepl('infusion', filename))\n",
    "    FW_data <<- dplyr::filter(CDR3_fraction, grepl('4W', filename))\n",
    "    Base_data <<- CDR3_fraction[which(CDR3_fraction$filename==samporder[1]),]\n",
    "} "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "# Quality Control"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "hidden": true,
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#########################\n",
    "# Quality Control Plots #\n",
    "#########################\n",
    "\n",
    "# Uses tabular log dataset from MiXCR to create and bind multiple quality control plots together showing different data points\n",
    "# @param alignstatsfile: Name of the tabular file containing the align stats \n",
    "# @param assemblestatsfile: Name of the tabular file containing the assemble stats file\n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param plotname: Name of the png to be printed with the aligned quality control plots\n",
    "# @param inpath: The path to the align and assemble stats files\n",
    "# @param plotpath: The path the png is to be printed into\n",
    "\n",
    "mixcrQC.fx <- function(alignstatsfile, assemblestatsfile, sampcohort, \n",
    "                       plotname, inpath, plotpath){\n",
    "    align_plots1 <- function (...) {\n",
    "    pl <- list(...)\n",
    "    stopifnot(do.call(all, lapply(pl, inherits, \"gg\")))\n",
    "    gl <- lapply(pl, ggplotGrob)\n",
    "    bind2 <- function(x, y) gtable:::rbind_gtable(x, y, \"first\")\n",
    "    combined <- Reduce(bind2, gl[-1], gl[[1]])\n",
    "    wl <- lapply(gl, \"[[\", \"widths\")\n",
    "    combined$widths <- do.call(grid::unit.pmax, wl)\n",
    "    grid::grid.newpage()\n",
    "    grid::grid.draw(combined)\n",
    "  }\n",
    "  \n",
    "    ## Plot Theme ##\n",
    "\n",
    "    # Creates the theme 'mytheme' which features no panel or coloured background. #\n",
    "\n",
    "    mytheme <- theme(axis.title.y = element_text(size = 28),\n",
    "                       axis.title.x = element_blank(),\n",
    "                       axis.line = element_line(color = \"black\"),\n",
    "                       axis.text = element_text(size = 28),\n",
    "                       axis.text.x = element_text(angle = 75, hjust = 1, size = 20)) +\n",
    "        theme(panel.grid.major = element_blank(),\n",
    "              panel.grid.minor = element_blank(),\n",
    "              panel.background = element_rect(fill = \"transparent\",colour = NA),  \n",
    "              legend.key = element_rect(fill = \"white\", colour = \"white\"),\n",
    "              plot.margin = unit(c(0,0,0,0),\"cm\"))    \n",
    "\n",
    "\n",
    "     ## Reading Log Files from MiXCR ##\n",
    "\n",
    "    # Reads the outputed align and assemble stats from the MiXCR software. #\n",
    "\n",
    "      alignstats <- read.csv(file = paste(inpath,alignstatsfile, sep =\"\"),\n",
    "                             sep = \",\", header = T)    \n",
    "      assemblestats <- read.csv(file = paste(inpath, assemblestatsfile, sep =\"\"),\n",
    "                                sep = \",\", header = T)  \n",
    "      \n",
    "    # Creates a list of samples for the desired sample cohort\n",
    "    myfilenames <- alignstats$SampleID\n",
    "    samplelist <- myfilenames[grepl(sampcohort, myfilenames)]\n",
    "\n",
    "    ## Sample List Matching. #\n",
    "\n",
    "    # Matches the sample names to the previously generated SampleID column in the align and assemb\n",
    "    # files. NOTE: The SampleID column was added manually in order to ensure proper x axis ordering\n",
    "    # and size of the labels. \n",
    "\n",
    "      for(i in samplelist){\n",
    "        alignstats$samplename[grepl(i, alignstats$SampleID)] <- i\n",
    "      }    \n",
    "      alignstats <- alignstats[!is.na(alignstats$samplename),]\n",
    "\n",
    "      for(j in samplelist){\n",
    "        assemblestats$samplename[grepl(j, assemblestats$SampleID)] <- j\n",
    "      }\n",
    "      assemblestats <- assemblestats[!is.na(assemblestats$samplename),]\n",
    "\n",
    "    # Ensures that the samplename is in the same order as the samplelist. \n",
    "      alignstats$samplename <- factor(alignstats$samplename, levels = samplelist)\n",
    "      assemblestats$samplename <- factor(assemblestats$samplename, levels = samplelist)\n",
    "\n",
    "    ## Plot Creation from Quality Control Data ##\n",
    "    \n",
    "    # 'myplot_totalseq_align_seq' creates the plot that uses both the 'Total.sequencing.reads' and the 'Successfully.aligned.reads'\n",
    "    # from the align stats file.              \n",
    "    \n",
    "    myplot_totalseq_align_seq <- ggplot(aes(x = samplename), \n",
    "                                data = alignstats) +\n",
    "        geom_point(aes(y = Total.sequencing.reads),size = 7) +\n",
    "        geom_point(aes(y = Successfully.aligned.reads),size = 7,color=\"#FF0000\") +\n",
    "        mytheme + theme(axis.text.x = element_blank()) +\n",
    "        scale_y_continuous(\"Total Reads\",sec.axis = dup_axis(name=\"Total Aligned Reads\\n\"))\n",
    "    myplot_totalseq_align_seq <- myplot_totalseq_align_seq + theme(axis.title.y.right = element_text(color=\"#FF0000\"))\n",
    "    \n",
    "    # 'myplot_percentalignedreads' creates the plot which uses the data \n",
    "    \n",
    "    myplot_percentalignedreads <- ggplot(data=alignstats, aes(x=samplename, y=Percent.Aligned.Reads)) + \n",
    "        geom_bar(stat=\"identity\") + mytheme + theme(axis.text.x=element_blank()) + ylim(0,100)\n",
    "    \n",
    "    \n",
    "\n",
    "    #'myplot_averagereads' creates the plot that uses the data 'Average.number.of.reads.per.clonotype' \n",
    "    # from the assemble stats file.                                                                    \n",
    "\n",
    "      myplot_averagereads <- ggplot(aes(x = samplename, y = Average.number.of.reads.per.clonotype), \n",
    "                                    data = assemblestats) + \n",
    "        geom_point(size = 7) + \n",
    "        mytheme +\n",
    "        theme(axis.text.x = element_blank())\n",
    "\n",
    "    #'myplot_readsused' creates the plot that uses the data 'Reads.used.in.clonotypes.before.clustering \n",
    "    # ..percent.of.total' from the assemble stats file.                                                                                                                  #\n",
    "\n",
    "      myplot_readsused <- ggplot(aes(x = samplename, y = Reads.used.in.clonotypes.before.clustering..percent.of.total),       \n",
    "                                 data = assemblestats) + \n",
    "        geom_point(size = 7) + \n",
    "        mytheme + \n",
    "        theme(axis.text.x = element_blank())\n",
    "\n",
    "    #'myplot_totalclon' creates the plot that uses the data 'Final.clonotype.count' from the assemble \n",
    "    # stats file                                                                                      \n",
    "\n",
    "      myplot_totalclon <- ggplot(aes(x = samplename, y = Final.clonotype.count),        \n",
    "                                 data = assemblestats) + \n",
    "        geom_point(size = 7) + \n",
    "        mytheme\n",
    "\n",
    "    # Exports all plots as pdfs combined using the 'align_plots1' function created earlier \n",
    "      png(file = paste(plotpath, plotname, sep = \"\"),\n",
    "          width = 13000, \n",
    "          height = 8000,\n",
    "          res = 300)\n",
    "      align_plots1(myplot_totalseq_align_seq,\n",
    "                   myplot_percentalignedreads + ylab(\"Percentage \\nAligned Reads\"),\n",
    "                   myplot_readsused + ylab(\"Reads used \\nin clonotypes\"),\n",
    "                   myplot_averagereads + ylab(\"Average \\nreads/clonotype\"),\n",
    "                   myplot_totalclon + ylab(\"Total clonotypes\"))    \n",
    "      dev.off()  \n",
    "    }                              "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "################################\n",
    "# Unproductive Clones Analysis #\n",
    "################################\n",
    "\n",
    "# Analyzes the unproductive data consumption of the patient's clones\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param datapath: Path to desired files\n",
    "# @param filename: Desired name of the output unproductive clones csv file\n",
    "\n",
    "clonstatfx <- function(chain, datapath, filename, dir_output){\n",
    "    \n",
    "flelst <- list.files(datapath,\n",
    "                     recursive = TRUE,\n",
    "                     pattern = paste(\"CLONES\", chain, sep = \"_\"))\n",
    "\n",
    "# Creates a list of files and presents them to the user\n",
    "flelst <- flelst[grepl(chain, flelst)]\n",
    "    message(\"list of files:\")\n",
    "    print(flelst)\n",
    "  \n",
    "  # Creates the dataframe to store the unproductive clones data\n",
    "  clones <- cbind.data.frame(flelst,\n",
    "                    NA, NA, NA, NA)\n",
    "  colnames(clones) <- c(\"filename\", \"total\",\n",
    "                        \"out_of_frame\", \"stopcodon\",\n",
    "                       \"productive\")\n",
    "\n",
    "  # For each file in the clones dataframe, the data is loaded and the amount of unproductive clones are recorded and data is stored in the clones dataframe\n",
    "  for(i in 1:nrow(clones)){\n",
    "    f <- clones$filename[i]\n",
    "    mixcrfle <- read.table(paste0(datapath, f),\n",
    "                           header = TRUE, sep = \"\\t\",\n",
    "                           stringsAsFactors = FALSE,\n",
    "                           na.strings = c(\"\", \"NA\"))\n",
    "\n",
    "    clones[i,colnames(clones) == \"total\"] <- length(mixcrfle$aaSeqCDR3)\n",
    "    clones[i,colnames(clones) == \"out_of_frame\"] <- length(mixcrfle$aaSeqCDR3[grepl(\"_\", mixcrfle$aaSeqCDR3)])\n",
    "    clones[i,colnames(clones) == \"stopcodon\"] <- length(mixcrfle$aaSeqCDR3[grepl(\"[*]\", mixcrfle$aaSeqCDR3) &\n",
    "                                                                             !grepl(\"_\", mixcrfle$aaSeqCDR3)])\n",
    "    clones[i,colnames(clones) == \"productive\"] <-  length(mixcrfle$aaSeqCDR3[!grepl(\"[*]\", mixcrfle$aaSeqCDR3) &\n",
    "                                                                             !grepl(\"_\", mixcrfle$aaSeqCDR3)])\n",
    "\n",
    "  }\n",
    "  \n",
    "  # A CSV file is written to store the clones and exported\n",
    "  write.csv(clones,\n",
    "         file = paste(dir_output, \"clonstats_\", chain,\n",
    "                       filename, \".csv\", sep = \"\"),\n",
    "         row.names = F)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plot Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "## Plot Alignment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "###################\n",
    "# Plot Alignment #\n",
    "##################\n",
    "\n",
    "# Creates list of high, medium, and low responding patients to be used in the function as well as the general order of samples in a patient timeline\n",
    "high <- c(\"TLML_1_\", \"TLML_16\", \"TLML_22\", \"TLML_26\", \"TLML_29\")\n",
    "med <- c(\"TLML_4_\", \"TLML_7_\", \"TLML_20\")\n",
    "low <- c(\"TLML_18\", \"TLDC_1_\")\n",
    "order <- c(\"Baseline\", \"TIL Infusion Product\", \"4 week sample\", \"Second Sample\", \"Third Sample\", \"Fourth Sample\", \"Fifth Sample\", \"Sixth Sample\")\n",
    "\n",
    "# Aligns the clone tracking plots with a single x-axis\n",
    "# @param patients: list of patients for plot alignment, could be high, med, or low \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param figure: figure wanting to be created (clonetrack, diversity, or relative)\n",
    "# @param primary: desired sample to appear first (Baseline or TIL)\n",
    "# @param dir_output: directory to put the png output into\n",
    "# @param file_output: desired filename to output \n",
    "\n",
    "alignment_fig <- function(patients, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys,\n",
    "                          file_samplekeys, figure, primary, dir_output, file_output){\n",
    "    \n",
    "    # Creates a list of the number of samples for each patient and finds the patient with the maximum amount of samples\n",
    "    lst <- list()\n",
    "    for(i in 1:length(patients)){\n",
    "        lst[[i]] <- length(eval(as.name(paste(patients[i], sampcohort, sep=\"\"))))\n",
    "    }\n",
    "    max <- as.numeric(lst[(which.max(lst))])\n",
    "    x_labs <- order[1:max]\n",
    "    \n",
    "    # Creates a list of the required widths of each of the patients plots based on their number of samples compared to the patient with the maximum number of samples\n",
    "    widths <- list()\n",
    "    for(i in 1:length(patients)){\n",
    "        widths[i] <- (length(eval(as.name(paste(patients[i], sampcohort, sep=\"\")))))/(max)\n",
    "    }\n",
    "    widths <- c(unlist(widths))\n",
    "    \n",
    "    width_df <- as.data.frame(widths)\n",
    "    width_df$patients <- patients\n",
    "    width_df <- width_df[order(width_df$widths),]\n",
    "            \n",
    "    # Assigns patient name to the variable storing the x-axis deprived plot for each patient in the inputted list\n",
    "    pltlst <- list()\n",
    "    for(i in 1:length(patients)){\n",
    "        if(figure==\"clonetrack\"){\n",
    "            ClonetrackPlot(width_df$patients[i], sampcohort, chain, clnefrc, dir_clones, \n",
    "                           dir_samplekeys, file_samplekeys, primary)\n",
    "        }\n",
    "        if(figure==\"diversity\"){\n",
    "            DivPlot(width_df$patients[i], sampcohort, chain, clnefrc, dir_clones, \n",
    "                           dir_samplekeys, file_samplekeys, primary, 500)\n",
    "        }\n",
    "        if(figure==\"relative\"){\n",
    "            RelPlot(width_df$patients[i], sampcohort, chain, clnefrc, dir_clones, \n",
    "                           dir_samplekeys, file_samplekeys, primary)\n",
    "        }\n",
    "        myp1 <- myp + theme(axis.text.x = element_blank(), axis.text.y = element_blank(), axis.title.y = element_blank())\n",
    "    \n",
    "        assign(width_df$patients[i], myp1)\n",
    "        pltlst[[i]] <- eval(as.name(width_df$patients[i]))\n",
    "    }\n",
    "    \n",
    "    # For each possible length of list of patients, the plots are aligned on the same x-axis plot  \n",
    "    if(length(patients)==5){\n",
    "        all_plots <- ggdraw() + \n",
    "            draw_plot(eval(as.name(width_df$patients[1])), 0, 4/5, width_df$widths[1], 1/5) + \n",
    "            draw_plot(eval(as.name(width_df$patients[2])), 0, 3/5, width_df$widths[2], 1/5) +\n",
    "            draw_plot(eval(as.name(width_df$patients[3])), 0, 2/5, width_df$widths[3], 1/5) +\n",
    "            draw_plot(eval(as.name(width_df$patients[4])), 0, 1/5, width_df$widths[4], 1/5) + \n",
    "            draw_plot(eval(as.name(width_df$patients[5])), 0, 0, width_df$widths[5], 1/5) \n",
    "    }\n",
    "    if(length(patients)==4){\n",
    "        all_plots <- ggdraw() + \n",
    "            draw_plot(eval(as.name(width_df$patients[1])), 0, 0.75, width_df$widths[1], 0.25) + \n",
    "            draw_plot(eval(as.name(width_df$patients[2])), 0, 0.5, width_df$widths[2], 0.25) +\n",
    "            draw_plot(eval(as.name(width_df$patients[3])), 0, 0.25, width_df$widths[3], 0.25) +\n",
    "            draw_plot(eval(as.name(width_df$patients[4])), 0, 0, width_df$widths[4], 0.25)\n",
    "    }\n",
    "    if(length(patients)==3){\n",
    "        all_plots <- ggdraw() + \n",
    "            draw_plot(eval(as.name(width_df$patients[1])), 0, 2/3, width_df$widths[1], 1/3, scale=1) + \n",
    "            draw_plot(eval(as.name(width_df$patients[2])), 0, 1/3, width_df$widths[2], 1/3, scale=1) +\n",
    "            draw_plot(eval(as.name(width_df$patients[3])), 0, 0, width_df$widths[3], 1/3, scale=1)\n",
    "    }\n",
    "    if(length(patients)==2){\n",
    "        all_plots <- ggdraw() + \n",
    "            draw_plot(eval(as.name(width_df$patients[1])), 0, 0.5, width_df$widths[1], 0.5) + \n",
    "            draw_plot(eval(as.name(width_df$patients[2])), 0, 0, width_df$widths[2], 0.5) \n",
    "    }\n",
    "    \n",
    "    # The final plot is printed as a png\n",
    "    png(file = paste(dir_output, file_output, \".png\", sep=\"\"),\n",
    "        width = 400*max,\n",
    "        height = 800*length(patients),\n",
    "        res=300)\n",
    "   print(all_plots)\n",
    "   dev.off()\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "## Clone Tracking"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "##################\n",
    "# Clone Tracking #\n",
    "##################\n",
    "\n",
    "# Plots and tracks the redundant TIL clones\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param primary: desired sample to appear first (Baseline or TIL)\n",
    "\n",
    "ClonetrackPlot <- function(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys,\n",
    "                          file_samplekeys, primary){\n",
    "\n",
    "# Loading the data for the patient for a specific sampcohort, chain, and clone fraction\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "        \n",
    "    # Assigning the sample order to the predefined lists created in the data load section\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    \n",
    "    # Pulls relative gDNA TIL Infusion product if the sample does not have an infusion\n",
    "    if(length(TIL_data$aaSeqCDR3) == 0){\n",
    "        files <- list.files(paste(dir_clones ,\"gDNA/CLONES_\", chain, patient, \"/\", sep = \"\"))\n",
    "        infusion <- files[grep('fusion', files)]\n",
    "        len <- length(samporder)\n",
    "        TIL_data <- data.frame()\n",
    "        TIL_data <- read.table(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", infusion, sep = \"\"), \n",
    "                   header = TRUE, sep = \"\\t\",\n",
    "                       stringsAsFactors = FALSE,\n",
    "                       na.strings = c(\"\", \"NA\"))\n",
    "        TIL_data <- TIL_data[!duplicated(TIL_data$aaSeqCDR3),]\n",
    "        TIL_data <- cbind(cloneno = row.names(TIL_data), \n",
    "                     filename = 'TIL Infusion Product', \n",
    "                   TIL_data)\n",
    "        TIL_data <- TIL_data[, c(\"filename\",\"aaSeqCDR3\",\"cloneFraction\", \"cloneCount\")]\n",
    "        # Subset to include only clonotypes with more than specified clonal fraction    \n",
    "        TIL_data <- TIL_data[TIL_data$cloneFraction > clnefrc,] \n",
    "        # Append the singletons\n",
    "        TIL_data <- TIL_data[(TIL_data$cloneCount>1),]        \n",
    "        # Removes unproductive clonotypes  \n",
    "        TIL_data <- TIL_data[-c(grep(\"[*]\", TIL_data$aaSeqCDR3)),]\n",
    "        TIL_data <- TIL_data[-c(grep(\"_\", TIL_data$aaSeqCDR3)),]\n",
    "\n",
    "        # Readjusting clonal fraction values to spliced data\n",
    "        ProdcloneFrac(TIL_data)\n",
    "        TIL_data <- output_df       \n",
    "        # Generating dataframe with added gDNA TIL Infusion product and updated y-axis order for plots\n",
    "        CDR3_fraction <- rbind(Base_data, TIL_data, FW_data)\n",
    "        samporder <- c(samporder[1],'TIL Infusion Product',samporder[2:len])\n",
    "    }\n",
    "    \n",
    "    # Generates list of clones and assigns them to previously created distinct colour pallete\n",
    "    colored_clns <-  unique(CDR3_fraction[order(tolower(CDR3_fraction$filename)),]$aaSeqCDR3[which(duplicated(CDR3_fraction[order(tolower(CDR3_fraction$filename)),]$aaSeqCDR3)==TRUE)])\n",
    "    colored_clns <- colored_clns[colored_clns %in% TIL_data$aaSeqCDR3]\n",
    "    non_clns <- CDR3_fraction$aaSeqCDR3[!CDR3_fraction$aaSeqCDR3 %in% colored_clns]\n",
    "    message(\"Total number of coloured clonotypes:\")\n",
    "    print(length(colored_clns))\n",
    "    mycolors <- colors[1:length(colored_clns)]\n",
    "    mycolors <- c(mycolors, rep(\"white\", length(non_clns)))\n",
    "    names(mycolors) <- c(colored_clns, non_clns)\n",
    "    \n",
    "    # Reorders the sample if the user specifies the TIL Infusion product to appear first\n",
    "    if(primary==\"TIL\"){\n",
    "        samporder <- samporder[c(which(grepl(\"infusion\", samporder)==TRUE), which(grepl(\"infusion\", samporder)==FALSE))]  \n",
    "    }\n",
    "    \n",
    "\n",
    "    # Orders filenames based on chronological sample order\n",
    "    CDR3_fraction$filename <- factor(CDR3_fraction$filename, levels = c(samporder))\n",
    "    levels(CDR3_fraction$filename) <- c(samporder)\n",
    "\n",
    "    # Creates plot for the data frame and list of colors and associated CDR3 sequences\n",
    "    p <- ggplot(CDR3_fraction, aes(x = filename, \n",
    "                              y = cloneFraction,\n",
    "                              fill = aaSeqCDR3,\n",
    "                              stratum = aaSeqCDR3,\n",
    "                              alluvium = aaSeqCDR3)) + \n",
    "        geom_alluvium(decreasing = FALSE) + \n",
    "        geom_stratum(decreasing = FALSE, stat = \"alluvium\") + \n",
    "        scale_fill_manual(breaks = names(mycolors[mycolors != \"white\"]),values = mycolors)\n",
    "        \n",
    "\n",
    "    myp <<- p + ylab(patient) +\n",
    "        theme(axis.title.y = element_text(size = 13, angle=0, vjust=0.5),\n",
    "              axis.title.x = element_blank(),\n",
    "              axis.line = element_line(color = \"black\"),\n",
    "              axis.text = element_text(size = 13),\n",
    "              axis.text.x = element_text(angle = 50, hjust = 1)) +\n",
    "        theme(panel.grid.major = element_blank(),\n",
    "          panel.grid.minor = element_blank(),\n",
    "          panel.background = element_rect(fill = \"transparent\",colour = NA),\n",
    "          legend.position = \"blank\",\n",
    "          plot.margin = unit(c(0.2,0,0,0),\"cm\"))\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "## Inverse Simpson Diversity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "#############################\n",
    "# Inverse Simpson Diversity #\n",
    "#############################\n",
    "\n",
    "# Plots and tracks the inverse simpson diversity\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param primary: desired sample to appear first (Baseline or TIL)\n",
    "# @param max: desired maximum diversity value, outliers will be shown as a triangle\n",
    "\n",
    "DivPlot <- function(patient, sampcohort, chain, clnefrc, dir_clones, \n",
    "                    dir_samplekeys, file_samplekeys, primary, max){\n",
    "    \n",
    "    # Loading in patient data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # Setting the longitudinal order of the samples for patient\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    \n",
    "    # Creating outline for diversity dataframe\n",
    "    Div_df <- data.frame(matrix(NA, nrow=length(samporder), ncol=3))\n",
    "    Div_df$X1 <- samporder\n",
    "    colnames(Div_df) <- c(\"Filename\", \"Diversity\", \"Shape\")\n",
    "    \n",
    "    # Filling in dataframe values with previously loaded data\n",
    "    for(i in 1:length(unique(CDR3_fraction$filename))){\n",
    "        CDR3_df <- CDR3_fraction[which(CDR3_fraction$filename==samporder[i]),]\n",
    "        CDR3_df <- CDR3_df[2:4]\n",
    "        colnames(CDR3_df) <- c(\"CDR3.aa\", \"Proportion\", \"Clones\")\n",
    "        Div_df$Diversity[i] <- repDiversity(CDR3_df, .method=\"inv.simp\")\n",
    "        if(Div_df$Diversity[i]>max){\n",
    "            Div_df$Shape[i] <- 17\n",
    "            Div_df$Diversity[i] <- max\n",
    "        }\n",
    "        else{\n",
    "            Div_df$Shape[i] <- 16\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Reorders the order of samples based on desired primary sample\n",
    "     if(primary==\"TIL\"){\n",
    "        samporder <- samporder[c(which(grepl(\"infusion\", samporder)==TRUE), which(grepl(\"infusion\", samporder)==FALSE))]  \n",
    "    }\n",
    "    \n",
    "    # Orders filenames based on chronological sample order\n",
    "    Div_df$Filename <- factor(Div_df$Filename, levels = c(samporder))\n",
    "    levels(Div_df$Filename) <- c(samporder)\n",
    "    \n",
    "    # Creates plot assigned to 'myp' global variable\n",
    "    p <- ggplot(Div_df) + geom_line(aes(x=Filename, y=Diversity, group=1), stat=\"identity\", color=\"#E7B800\", size=1.5) +\n",
    "                          geom_point(aes(x=Filename, y=Diversity, shape=factor(Shape)), colour=\"#E7B800\", size = 4.0)+\n",
    "                          scale_y_continuous(limits=c(0,max))\n",
    "    myp <<- p + ylab(patient) +\n",
    "        theme(axis.title.y = element_text(size = 13, angle=0, vjust=0.5),\n",
    "              axis.title.x = element_blank(),\n",
    "              axis.line = element_line(color = \"black\"),\n",
    "              axis.text = element_text(size = 13),\n",
    "              axis.text.x = element_text(angle = 50, hjust = 1)) +\n",
    "        theme(panel.grid.major = element_blank(),\n",
    "          panel.grid.minor = element_blank(),\n",
    "          panel.background = element_rect(fill = \"transparent\",colour = NA),\n",
    "          legend.position = \"blank\",\n",
    "          plot.margin = unit(c(0.2,0,0,0),\"cm\"))\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "## Relative Abundance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "######################\n",
    "# Relative Abundance #\n",
    "######################\n",
    "\n",
    "# Plots and tracks the relative abundance of large and hyperexpansive clones\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param primary: desired sample to appear first (Baseline or TIL)\n",
    "\n",
    "RelPlot <- function(patient, sampcohort, chain, clnefrc, dir_clones, \n",
    "                           dir_samplekeys, file_samplekeys, primary){\n",
    "\n",
    "    # Loads patient data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # Creates longitudinally ordered sample list\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "      \n",
    "    # Creates outline of relative abundance dataframe\n",
    "    Rel_df <- data.frame(matrix(NA, nrow=length(samporder), ncol=3))\n",
    "    Rel_df$X1 <- samporder\n",
    "    colnames(Rel_df) <- c(\"Filename\", \"RelativeHyper\", \"RelativeExp\")\n",
    "    \n",
    "    # Fills in relative abundance dataframe with amount of large and hyperexpansive clones\n",
    "    for(i in 1:length(unique(CDR3_fraction$filename))){\n",
    "        CDR3_df <- CDR3_fraction[which(CDR3_fraction$filename==samporder[i]),]\n",
    "        Rel_df$RelativeHyper[i] <- sum(CDR3_df[which(CDR3_df$cloneFraction>=0.05),]$cloneFraction)\n",
    "        Rel_df$RelativeExp[i] <- sum(CDR3_df[which(CDR3_df$cloneFraction<0.05 & CDR3_df$cloneFraction>0.005),]$cloneFraction)\n",
    "    }\n",
    "    \n",
    "    # Reorders dataframe with desired primary sample\n",
    "     if(primary==\"TIL\"){\n",
    "        samporder <- samporder[c(which(grepl(\"infusion\", samporder)==TRUE), which(grepl(\"infusion\", samporder)==FALSE))]  \n",
    "    }\n",
    "    \n",
    "    # Adjusts dataframe for plot production\n",
    "    Rel_df <- rbind(\n",
    "        data.frame(samporder, \"count\" = Rel_df$RelativeExp, \"type\" = \"Exp\"),\n",
    "        data.frame(samporder, \"count\" = Rel_df$RelativeHyper, \"type\" = \"Hyper\")\n",
    "    )\n",
    "    \n",
    "    \n",
    "    # Orders filenames based on chronological sample order\n",
    "    Rel_df$samporder <- factor(Rel_df$samporder, levels = c(samporder))\n",
    "    levels(Rel_df$samporder) <- c(samporder)\n",
    "    \n",
    "    \n",
    "    # Creates relative abundance 'myp' plot global variable\n",
    "    p <<- ggplot(Rel_df, aes(x=samporder, y=count, fill=type, alpha=0.5)) +\n",
    "        geom_bar(stat=\"identity\", width=1/3) + scale_fill_manual(values = c(\"steelblue\",\"goldenrod\")) +\n",
    "        scale_y_continuous(limits=c(0,1.0)) \n",
    "    \n",
    "    myp <<- p + ylab(patient) +\n",
    "        theme(axis.title.y = element_text(size = 13, angle=0, vjust=0.5),\n",
    "              axis.title.x = element_blank(),\n",
    "              axis.line = element_line(color = \"black\"),\n",
    "              axis.text = element_text(size = 13),\n",
    "              axis.text.x = element_text(angle = 50, hjust = 1)) +\n",
    "        theme(panel.grid.major = element_blank(),\n",
    "          panel.grid.minor = element_blank(),\n",
    "          panel.background = element_rect(fill = \"transparent\",colour = NA),\n",
    "          legend.position = \"blank\",\n",
    "          plot.margin = unit(c(0.2,0,0,0),\"cm\"))\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sample Cohort Correlation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "#############################\n",
    "# Sample Cohort Correlation #\n",
    "#############################\n",
    "\n",
    "# Plots the correlative overlap between sample cohorts (gDNA, cDNA, cfDNA)\n",
    "# @param sampcohort1: Desired first sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param sampcohort2: Desired second sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param dir_output: directory for the output png\n",
    "# @param file_output: png file name\n",
    "\n",
    "rsq <- function (x, y) cor(x, y) ^ 2\n",
    "\n",
    "SampleCohort_Correl <- function(sampcohort1, sampcohort2, chain, clnefrc, dir_clones, dir_samplekeys, \n",
    "                               file_samplekeys, dir_output, file_output){\n",
    "    \n",
    "    #List of patients required for analysis (requires manual change)\n",
    "    patients <- c(\"TLML_4_\", \"TLML_7_\", \"TLML_18\", \"TLML_20\", \"TLML_22\",\n",
    "                  \"TLML_26\", \"TLML_29\", \"TLDC_1_\")\n",
    "\n",
    "    # Loops through the patients and loads the data from the 2 desired sample cohorts in one dataframe\n",
    "    for(patient in patients){\n",
    "        Load_data(patient, sampcohort1, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "        Sample1_fraction <- FW_data[c(\"aaSeqCDR3\", \"cloneFraction\")]\n",
    "        Sample1_fraction$clone2_Fraction <- NA\n",
    "        \n",
    "        Load_data(patient, sampcohort2, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "        Sample2_fraction <- FW_data[c(\"aaSeqCDR3\", \"cloneFraction\")]\n",
    "        \n",
    "        Sample1_fraction$clone2_Fraction <- Sample2_fraction$cloneFraction[match(Sample1_fraction$aaSeqCDR3, Sample2_fraction$aaSeqCDR3)]\n",
    "        #Removing all rows with NA values\n",
    "        Sample1_fraction <- na.omit(Sample1_fraction)\n",
    "        \n",
    "        assign(paste(patient, \"merged\", sep=\"\"), Sample1_fraction)\n",
    "    }\n",
    "\n",
    "    # Binds all of the patient's data together\n",
    "    Ov_data <- rbind(TLML_4_merged, TLML_7_merged, TLML_18merged,\n",
    "                     TLML_20merged, TLML_22merged, TLML_26merged, TLML_29merged, TLDC_1_merged)\n",
    "\n",
    "    # Calculates and prints R^2 value\n",
    "    print(rsq(Ov_data$cloneFraction, Ov_data$clone2_Fraction))\n",
    "    \n",
    "    # Creates plot assigned to 'myp' global variable\n",
    "    p <- ggplot(Ov_data, aes(x=cloneFraction, y=clone2_Fraction)) + geom_point(size=2, color=\"steelblue\")\n",
    "    myp <<- p + \n",
    "        scale_y_continuous(n.breaks=4, trans=\"log10\") + scale_x_continuous(n.breaks=4, trans=\"log10\") + geom_smooth(method=lm) +\n",
    "        theme(axis.title.y = element_blank(),\n",
    "              axis.title.x = element_blank(),\n",
    "              axis.line = element_line(color = \"black\"),\n",
    "              axis.text = element_text(size = 13),\n",
    "              axis.text.x = element_text(angle = 50, hjust = 1)) +\n",
    "        theme(panel.grid.major = element_blank(),\n",
    "          panel.grid.minor = element_blank(),\n",
    "          panel.background = element_rect(fill = \"transparent\",colour = NA),\n",
    "          legend.position = \"blank\",\n",
    "          plot.margin = unit(c(0.2,0,0,0),\"cm\"))\n",
    " \n",
    "    # The final plot is printed as a png\n",
    "    png(file = paste(dir_output, file_output, \".png\", sep=\"\"),\n",
    "        width = 3000,\n",
    "        height = 3000,\n",
    "        res=300)\n",
    "   print(myp)\n",
    "   dev.off() \n",
    "    \n",
    "}                                "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "# Calculation Functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Top 50% Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "####################\n",
    "# Top 50% Analysis #\n",
    "####################\n",
    "\n",
    "# Finds the amount of a sample taken up by the top 50% of another sample\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param Top50: sample which will have its top 50% compared\n",
    "# @param Reference: sample which will be compared to \n",
    "# @param dir_clones: directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys file is located\n",
    "# @param file_samplekeys: name of the sample keys file\n",
    "\n",
    "Top50.fx <- function(patient, sampcohort, chain, clnefrc, Top50, Reference,\n",
    "                    dir_clones, dir_samplekeys, file_samplekeys){\n",
    "    \n",
    "    # Loads patient sample order\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "\n",
    "    # Loads patient clone data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "\n",
    "    #Creating dataframes for the clones of the Top50 and Reference samples\n",
    "    Top50Samp <- CDR3_fraction[which(CDR3_fraction$filename==grep(Top50, samporder, value=TRUE)),]\n",
    "    ReferenceSamp <- CDR3_fraction[which(CDR3_fraction$filename==grep(Reference, samporder, value=TRUE)),]\n",
    "    \n",
    "    # Creating dataframe showing both the clone fractions of the top 50 and reference sample datasets\n",
    "    Reference_clonefraction <- NA\n",
    "    Top50Data <- cbind(Top50Samp, Reference_clonefraction)\n",
    "    Top50Data$Reference_clonefraction <- ReferenceSamp$cloneFraction[match(Top50Data$aaSeqCDR3, ReferenceSamp$aaSeqCDR3)]\n",
    "\n",
    "    #Converting all NA values to 0\n",
    "    Top50Data[is.na(Top50Data)] <- 0\n",
    "\n",
    "    # Taking the top 50% of the Top50Data\n",
    "    Top50Spliced <- data.frame()\n",
    "    f <- 1\n",
    "    Top50Frc <- 0\n",
    "    for(i in Top50Data$cloneFraction){\n",
    "        if(Top50Frc < 0.5){\n",
    "            Top50Frc <- Top50Frc + i\n",
    "            Top50Spliced <- rbind(Top50Spliced, Top50Data[f,])\n",
    "            f <- f + 1\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Calculating the fraction of the reference sample taken up by the clones in the top 50% of the Top50 sample\n",
    "    ReferenceFrc <- sum(Top50Spliced$Reference_clonefraction)\n",
    "    print(ReferenceFrc)\n",
    "\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## TIL Characteristic Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "###############################\n",
    "# TIL Characteristic Analysis #\n",
    "###############################\n",
    "\n",
    "# Analyzes the amount of clones >5% in the TIL sample, total number of TCRs and the total amount of TIL clones\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param char: The characteristic desired to be analyzed (Clonotypes, TCRCount, or Oligo)\n",
    "# @param sample: the sample which is used in the analysis\n",
    "# @param dir_clones: directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys file is located\n",
    "# @param file_samplekeys: name of the sample keys file\n",
    "\n",
    "TIL_char <- function(patient, sampcohort, chain, clnefrc, char, sample, dir_clones, dir_samplekeys, file_samplekeys){\n",
    "    \n",
    "    # Loads longitudinal sample order\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    options(scipen = 999)\n",
    "    \n",
    "    #Loads patient clone data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    reference_data <- CDR3_fraction[which(CDR3_fraction$filename==sample),]\n",
    "    \n",
    "    # Prints the total amount of TIL clones if specified by the user\n",
    "    if(char==\"Clonotypes\"){\n",
    "        Total <- nrow(reference_data)\n",
    "        print(Total)\n",
    "    }\n",
    "    \n",
    "    if(char==\"TCRCount\"){\n",
    "        TCRCount <- sum(reference_data$cloneCount)\n",
    "        print(TCRCount)\n",
    "    }\n",
    "    \n",
    "    # Prints the fraction of clones >5% in the TIL sample if specified by the user\n",
    "    if(char==\"Oligo\"){\n",
    "        Sum_Oligo <- sum(reference_data$cloneFraction)\n",
    "        print(Sum_Oligo)\n",
    "    }\n",
    "    if(char==\"AvgCloneFrac\"){\n",
    "        AvgCloneFrac <- sum(reference_data$cloneFraction)/nrow(reference_data)\n",
    "        print(AvgCloneFrac)\n",
    "    }\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Amount of TIL clones in Alternate Samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "############################################\n",
    "# Amount of TIL clones in Alternate Sample #\n",
    "############################################\n",
    "\n",
    "# Calculating the amount of a sample's repertoire is taken up by TIL-related clones\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param sample: the sample which is subjected to TIL clone calculation\n",
    "# @param expanded: boolean parameter, if TRUE the clones that are larger in the reference \n",
    "#                  than the TIL-infusion will be selected. Default is FALSE\n",
    "# @param dir_clones: directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys file is located\n",
    "# @param file_samplekeys: name of the sample keys file\n",
    "\n",
    "TIL_calc <- function(patient, sampcohort, chain, clnefrc, sample, expanded=FALSE, dir_clones, dir_samplekeys, file_samplekeys){\n",
    "    \n",
    "    #Loads longitudinal sample ordering\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    options(scipen = 999)\n",
    "    \n",
    "    #Loads patient, sampcohort, chain specific data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # If a patient doesn't have a TIL file, it will use the TIL file from the related gDNA TIL data from the patient\n",
    "    if(length(TIL_data$aaSeqCDR3) == 0){\n",
    "        files <<- list.files(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", sep = \"\"))\n",
    "        infusion <- files[grep('fusion', files)]\n",
    "        len <<- length(samporder)\n",
    "        TIL_data <- data.frame()\n",
    "        TIL_data <- read.table(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", infusion, sep = \"\"), \n",
    "                   header = TRUE, sep = \"\\t\",\n",
    "                       stringsAsFactors = FALSE,\n",
    "                       na.strings = c(\"\", \"NA\"))\n",
    "        TIL_data <- TIL_data[!duplicated(TIL_data$aaSeqCDR3),]\n",
    "        TIL_data <- cbind(cloneno = row.names(TIL_data), \n",
    "                     filename = 'TIL Infusion Product', \n",
    "                   TIL_data)\n",
    "        TIL_data <- TIL_data[, c(\"filename\",\"aaSeqCDR3\",\"cloneFraction\", \"cloneCount\")]\n",
    "        # Subset to include only clonotypes with more than specified clonal fraction    \n",
    "        TIL_data <- TIL_data[TIL_data$cloneFraction > clnefrc,] \n",
    "        # Append the singletons\n",
    "        TIL_data <- TIL_data[(TIL_data$cloneCount>1),]        \n",
    "        # Removes unproductive clonotypes  \n",
    "        TIL_data <- TIL_data[-c(grep(\"[*]\", c(TIL_data$aaSeqCDR3, \"CDR3*\"))),]\n",
    "        TIL_data <- TIL_data[-c(grep(\"_\", c(TIL_data$aaSeqCDR3, \"CDR3*\"))),]\n",
    "\n",
    "        # Readjusting clonal fraction values to spliced data\n",
    "        ProdcloneFrac(TIL_data)\n",
    "        TIL_data <- output_df\n",
    "    }\n",
    "    # Creates dataframe including the clones which are prevalent in both the reference and TIL-infusion sample\n",
    "    reference_data <- CDR3_fraction[which(CDR3_fraction$filename==sample),]\n",
    "    reference_data <- reference_data[reference_data$aaSeqCDR3 %in% TIL_data$aaSeqCDR3,]\n",
    "    \n",
    "   # Subsets the data frame to the expansive clones if desired by the user\n",
    "    if(expanded==TRUE){\n",
    "        reference_data$TIL_cloneFraction <- reference_data$cloneFraction[match(reference_data$aaSeqCDR3, TIL_data$aaSeqCDR3)]\n",
    "        reference_data <- reference_data[!(reference_data$cloneFraction < reference_data$TIL_cloneFraction),]\n",
    "        reference_data[is.na(reference_data)] <- 0\n",
    "    }\n",
    "    \n",
    "    # Calculates the amount of the sample is taken up by TIL-infusion clones and prints the result\n",
    "    response <- sum(reference_data$cloneFraction)\n",
    "    print(response)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Baseline TIL-clonotype counting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "###################################\n",
    "# Baseline TIL-clonotype counting #\n",
    "###################################\n",
    "\n",
    "# Calculating the amount of TIL-related clones in the baseline repertoire\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param char: desired characteristic to be analyzed ('clonotypes' or 'TCRs')\n",
    "# @param dir_clones: directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys file is located\n",
    "# @param file_samplekeys: name of the sample keys file\n",
    "\n",
    "\n",
    "Base_TILclone <- function(patient, sampcohort, chain, clnefrc, char, dir_clones, dir_samplekeys, file_samplekeys){\n",
    "    \n",
    "    # Loading specific locus and sampcohort 4W, TIL, and baseline samples for patient\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    if(length(TIL_data$aaSeqCDR3) == 0){\n",
    "        files <<- list.files(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", sep = \"\"))\n",
    "        infusion <- files[grep('fusion', files)]\n",
    "        TIL_data <- data.frame()\n",
    "        TIL_data <- read.table(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", infusion, sep = \"\"), \n",
    "                   header = TRUE, sep = \"\\t\",\n",
    "                       stringsAsFactors = FALSE,\n",
    "                       na.strings = c(\"\", \"NA\"))\n",
    "        TIL_data <- TIL_data[!duplicated(TIL_data$aaSeqCDR3),]\n",
    "        TIL_data <- cbind(cloneno = row.names(TIL_data), \n",
    "                     filename = 'TIL Infusion Product', \n",
    "                   TIL_data)\n",
    "        TIL_data <- TIL_data[, c(\"filename\",\"aaSeqCDR3\",\"cloneFraction\", \"cloneCount\")]\n",
    "        # Subset to include only clonotypes with more than specified clonal fraction    \n",
    "        TIL_data <- TIL_data[TIL_data$cloneFraction > clnefrc,] \n",
    "        # Append the singletons\n",
    "        TIL_data <- TIL_data[(TIL_data$cloneCount>1),]        \n",
    "        # Removes unproductive clonotypes  \n",
    "        TIL_data <- TIL_data[-c(grep(\"[*]\", TIL_data$aaSeqCDR3)),]\n",
    "        TIL_data <- TIL_data[-c(grep(\"_\", TIL_data$aaSeqCDR3)),]\n",
    "\n",
    "        # Readjusting clonal fraction values to spliced data\n",
    "        ProdcloneFrac(TIL_data)\n",
    "        TIL_data <- output_df\n",
    "    }\n",
    "    \n",
    "    # Filtering the base data by the clones in the TIL data\n",
    "    Base_filtered_data <- Base_data[Base_data$aaSeqCDR3 %in% TIL_data$aaSeqCDR3,]\n",
    "\n",
    "    if(char==\"clonotypes\"){\n",
    "        # Find the number of TIL-clonotypes in the baseline sample\n",
    "        result <- nrow(Base_filtered_data)\n",
    "    }\n",
    "    \n",
    "    if(char==\"TCRs\"){\n",
    "        # Find the number of TIL-TCRs in the baseline sample\n",
    "        result <- sum(Base_filtered_data$cloneCount)\n",
    "    }\n",
    "    print(result)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Diversity Data Evalutation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "########################\n",
    "# Diversity Evaluation #\n",
    "########################\n",
    "\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "# @param primary: desired sample to appear first (Baseline or TIL)\n",
    "# @param max: desired maximum diversity value, outliers will be shown as a triangle\n",
    "\n",
    "DivCalc <- function(patient, sampcohort, chain, clnefrc, dir_clones, \n",
    "                    dir_samplekeys, file_samplekeys){\n",
    "    \n",
    "    # Loading in patient data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # Setting the longitudinal order of the samples for patient\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    \n",
    "    # Creating outline for diversity dataframe\n",
    "    Div_df <- data.frame(matrix(NA, nrow=length(samporder), ncol=2))\n",
    "    Div_df$X1 <- samporder\n",
    "    colnames(Div_df) <- c(\"Filename\", \"Diversity\")\n",
    "    \n",
    "    # Filling in dataframe values with previously loaded data\n",
    "    for(i in 1:length(unique(CDR3_fraction$filename))){\n",
    "        CDR3_df <- CDR3_fraction[which(CDR3_fraction$filename==samporder[i]),]\n",
    "        CDR3_df <- CDR3_df[2:4]\n",
    "        colnames(CDR3_df) <- c(\"CDR3.nt\", \"Proportion\", \"Clones\")\n",
    "        Div_df$Diversity[i] <- repDiversity(CDR3_df, .method=\"inv.simp\")\n",
    "    }\n",
    "    \n",
    "    # Orders filenames based on chronological sample order\n",
    "    Div_df$Filename <- factor(Div_df$Filename, levels = c(samporder))\n",
    "    levels(Div_df$Filename) <- c(samporder)\n",
    "    \n",
    "    print(Div_df)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Delta Analysis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "##################\n",
    "# Delta Analysis #\n",
    "##################\n",
    "\n",
    "# Calculates the delta between 2 data points of different samples\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param datapoint: The data point wanted to be analyzed (Expansion, Productive, Expression, Diversity)\n",
    "# @param first: The name of the first sample\n",
    "# @param second: The name of the second sample\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "\n",
    "DeltaA <- function(patient, sampcohort, chain, clnefrc, datapoint, first, second, \n",
    "                   dir_clones, dir_samplekeys, file_samplekeys){\n",
    "\n",
    "    # Loads in patient samporder\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    \n",
    "    # Loads in patient data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # If a patient doesn't have a TIL file, it will use the TIL file from the related gDNA TIL data from the patient\n",
    "    if(length(TIL_data$aaSeqCDR3) == 0){\n",
    "        files <<- list.files(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", sep = \"\"))\n",
    "        infusion <- files[grep('fusion', files)]\n",
    "        len <<- length(samporder)\n",
    "        TIL_data <- data.frame()\n",
    "        TIL_data <- read.table(paste(dir_clones, \"gDNA/CLONES_\", chain, patient, \"/\", infusion, sep = \"\"), \n",
    "                   header = TRUE, sep = \"\\t\",\n",
    "                       stringsAsFactors = FALSE,\n",
    "                       na.strings = c(\"\", \"NA\"))\n",
    "        TIL_data <- TIL_data[!duplicated(TIL_data$aaSeqCDR3),]\n",
    "        TIL_data <- cbind(cloneno = row.names(TIL_data), \n",
    "                     filename = 'TIL Infusion Product', \n",
    "                   TIL_data)\n",
    "        TIL_data <- TIL_data[, c(\"filename\",\"aaSeqCDR3\",\"cloneFraction\", \"cloneCount\")]\n",
    "        # Subset to include only clonotypes with more than specified clonal fraction    \n",
    "        TIL_data <- TIL_data[TIL_data$cloneFraction > clnefrc,] \n",
    "        # Append the singletons\n",
    "        TIL_data <- TIL_data[(TIL_data$cloneCount>1),]        \n",
    "        # Removes unproductive clonotypes  \n",
    "        TIL_data <- TIL_data[-c(grep(\"[*]\", c(TIL_data$aaSeqCDR3, \"CDR3*\"))),]\n",
    "        TIL_data <- TIL_data[-c(grep(\"_\", c(TIL_data$aaSeqCDR3, \"CDR3*\"))),]\n",
    "\n",
    "        # Readjusting clonal fraction values to spliced data\n",
    "        ProdcloneFrac(TIL_data)\n",
    "        TIL_data <- output_df\n",
    "    }\n",
    "    \n",
    "    # Changes the name of the baseline to the first name in the sample order previously creates\n",
    "    if(first=='BL'){\n",
    "        first <- eval(as.name(paste(patient, sampcohort, sep=\"\")))[1]\n",
    "    }\n",
    "    \n",
    "    # Loads the clone data for the first and second identified samples\n",
    "    df_first <- CDR3_fraction[which(grepl(first, CDR3_fraction$filename)==TRUE),]\n",
    "    df_second <- CDR3_fraction[which(grepl(second, CDR3_fraction$filename)==TRUE),]\n",
    "\n",
    "    # Finds the delta between the TIL clone fraction in the samples if user specified\n",
    "    if(datapoint==\"Expansion\"){\n",
    "        data_first <- sum(df_first[df_first$aaSeqCDR3 %in% TIL_data$aaSeqCDR3,]$cloneFraction)\n",
    "        data_second <- sum(df_second[df_second$aaSeqCDR3 %in% TIL_data$aaSeqCDR3,]$cloneFraction)\n",
    "        delta <- data_second - data_first\n",
    "    }\n",
    "\n",
    "    # Finds the delta between the productive clone fractions in the samples if user specified \n",
    "    if(datapoint==\"Productive\"){\n",
    "        unproductive$filename <- as.character(unproductive$filename)\n",
    "        # Changes the names of the file names in the 'CDR3_fraction' variable defined in the 'Load_data' function to readable format using the sample keys\n",
    "        for(i in 1:nrow(unproductive)){\n",
    "            unproductive$filename[i] <- sub(\"*genomic*\", \"DNA\", unproductive$filename[i])\n",
    "        }\n",
    "        h <- 1\n",
    "        for (f in unproductive$filename){\n",
    "            j <- 1\n",
    "            for(i in samplekeys$Informatics_Name){\n",
    "                if(grepl(i, f) == TRUE){\n",
    "                    file <- paste(samplekeys$Timepoint[j],\n",
    "                                samplekeys$Sample_Year[j],\n",
    "                                samplekeys$Sample_Month[j], sep=\"_\")\n",
    "                    test <- file\n",
    "                    unproductive$filename[h] <- file\n",
    "                }\n",
    "                j <- j+1\n",
    "            }\n",
    "            h <- h + 1\n",
    "        }\n",
    "        \n",
    "        df_first <- unproductive[which(grepl(first, unproductive$filename)==TRUE),]\n",
    "        df_second <- unproductive[which(grepl(second, unproductive$filename)==TRUE),]\n",
    "        \n",
    "        data_first <- length(df_first$aaSeqCDR3[!grepl(\"[*]\", df_first$aaSeqCDR3) & !grepl(\"_\", df_first$aaSeqCDR3)])/length(df_first$aaSeqCDR3)\n",
    "        data_second <- length(df_second$aaSeqCDR3[!grepl(\"[*]\", df_second$aaSeqCDR3) & !grepl(\"_\", df_second$aaSeqCDR3)])/length(df_second$aaSeqCDR3)\n",
    "        delta <- data_second - data_first\n",
    "    }\n",
    "    \n",
    "    # Finds the delta between the total clone count in the samples if user specified\n",
    "    if(datapoint==\"Expression\"){\n",
    "        data_first <- sum(df_first$cloneCount)\n",
    "        data_second <- sum(df_second$cloneCount)\n",
    "        delta = data_second - data_first\n",
    "    }\n",
    "    \n",
    "    # Finds the delta between the diversity in the samples if user specified\n",
    "    if(datapoint==\"Diversity\"){\n",
    "        # Changes the column names to be readable to the immunarch library\n",
    "        df_first <- df_first[2:4]\n",
    "        colnames(df_first) <- c(\"CDR3.nt\", \"Proportion\", \"Clones\")\n",
    "        df_second <- df_second[2:4]\n",
    "        colnames(df_second) <- c(\"CDR3.nt\", \"Proportion\", \"Clones\")\n",
    "        \n",
    "        data_first <- repDiversity(df_first, .method = \"inv.simp\")\n",
    "        data_second <- repDiversity(df_second, .method=\"inv.simp\")\n",
    "        \n",
    "        delta = data_second - data_first\n",
    "        \n",
    "    }\n",
    "    # Prints the resulting delta variable\n",
    "    print(delta)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "heading_collapsed": true,
    "hidden": true
   },
   "source": [
    "## Top 10 4W Clone Comparison"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "hidden": true
   },
   "outputs": [],
   "source": [
    "###########################################\n",
    "# Top 10 4 week clone fraction Comparison #\n",
    "###########################################\n",
    "\n",
    "# Calculates the clone fraction of the top 4 week clones in the baseline and TIL-infusion data\n",
    "# @param patient: specific patient code \n",
    "# @param sampcohort: Desired sample cohort, could be gDNA, cDNA, or cfDNA\n",
    "# @param chain: Desired chain to analyze, could be TRA, TRB, TRD, TRG\n",
    "# @param clnefrc: cut-off from 0 to 1 to track and plot only a subset of clonotypes\n",
    "# @param dir_clones: parent directory where clone files are located\n",
    "# @param dir_samplekeys: directory where the sample keys excel file are located\n",
    "# @param file_samplekeys: file name of the sample keys \n",
    "\n",
    "Top104WComp <- function(patient, sampcohort, chain, clnefrc, \n",
    "                   dir_clones, dir_samplekeys, file_samplekeys){\n",
    "\n",
    "    # Loads in patient data\n",
    "    Load_data(patient, sampcohort, chain, clnefrc, dir_clones, dir_samplekeys, file_samplekeys)\n",
    "    \n",
    "    # Loading patient sample order\n",
    "    samporder <- eval(as.name(paste(patient, sampcohort, sep=\"\")))\n",
    "    \n",
    "    # Create Top104W dataframe out of the top 10 clones in the 4 week sample\n",
    "    Top104W <- FW_data[1:10,]\n",
    "    Top104W$TIL_cloneFraction <- replicate(10, 0)\n",
    "    Top104W$Base_cloneFraction <- replicate(10, 0)\n",
    "    \n",
    "    # Fill in the TIL_cloneFraction and Base_cloneFraction with the clone fraction of the corresponding 4 week clone\n",
    "    for(i in 1:10){\n",
    "        if(length(TIL_data$cloneFraction[which(TIL_data$aaSeqCDR3 == Top104W$aaSeqCDR3[i])])>0){\n",
    "            Top104W$TIL_cloneFraction[i] <- TIL_data$cloneFraction[which(TIL_data$aaSeqCDR3 == Top104W$aaSeqCDR3[i])]\n",
    "        }\n",
    "        if(length(Base_data$cloneFraction[which(Base_data$aaSeqCDR3 == Top104W$aaSeqCDR3[i])])>0){\n",
    "            Top104W$Base_cloneFraction[i] <- Base_data$cloneFraction[which(Base_data$aaSeqCDR3 == Top104W$aaSeqCDR3[i])]\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    # Calculates and prints average cloneFraction for the TIL and Base Data for the top 10 4 week clones\n",
    "    TIL_cloneFraction <- sum(Top104W$TIL_cloneFraction)/10\n",
    "    Base_cloneFraction <- sum(Top104W$Base_cloneFraction)/10\n",
    "    print(TIL_cloneFraction)\n",
    "    print(Base_cloneFraction)\n",
    "}\n",
    "    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "R",
   "language": "R",
   "name": "ir"
  },
  "language_info": {
   "codemirror_mode": "r",
   "file_extension": ".r",
   "mimetype": "text/x-r-source",
   "name": "R",
   "pygments_lexer": "r",
   "version": "3.6.1"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
